{"remainingRequest":"C:\\Visual Studio Code\\sensor-frontend\\node_modules\\vue-loader-v16\\dist\\index.js??ref--1-1!C:\\Visual Studio Code\\sensor-frontend\\src\\components\\Chart.vue?vue&type=template&id=4d06a4de","dependencies":[{"path":"C:\\Visual Studio Code\\sensor-frontend\\src\\components\\Chart.vue","mtime":1635836126000},{"path":"C:\\Visual Studio Code\\sensor-frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1689390764583},{"path":"C:\\Visual Studio Code\\sensor-frontend\\node_modules\\babel-loader\\lib\\index.js","mtime":1689390766577},{"path":"C:\\Visual Studio Code\\sensor-frontend\\node_modules\\vue-loader-v16\\dist\\templateLoader.js","mtime":1689390768245},{"path":"C:\\Visual Studio Code\\sensor-frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1689390764583},{"path":"C:\\Visual Studio Code\\sensor-frontend\\node_modules\\vue-loader-v16\\dist\\index.js","mtime":1689390767075}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CiAgPGRpdiA6Y2xhc3M9ImBDaGFydCBDaGFydC0ke3R5cGV9YCI+CiAgICA8aDE+e3tzZW5zb3J9fTwvaDE+IAogIDwvZGl2Pgo="},{"version":3,"sources":["C:\\Visual Studio Code\\sensor-frontend\\src\\components\\Chart.vue"],"names":[],"mappings":";EACE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACjC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACpB,CAAC,CAAC,CAAC,CAAC,CAAC","file":"C:/Visual Studio Code/sensor-frontend/src/components/Chart.vue","sourceRoot":"","sourcesContent":["<template>\n  <div :class=\"`Chart Chart-${type}`\">\n    <h1>{{sensor}}</h1> \n  </div>\n</template>\n\n<script>\n  import {\n    margin,\n    chartWidth,\n    chartHeight\n  } from '../config'\n  import store from '../store'\n  import * as d3 from 'd3'\n  import {\n    onMounted,\n    computed\n  } from 'vue'  \n  const timeFormat = d3.timeFormat(\"%H:%M\")\n  export default {\n    name: 'Chart',\n    props: {\n      type: String,\n      text: String\n    },\n    setup(props) {\n      let svg, xScale, yScale, xAxis, yAxis, line, tooltip, circle, area  \n\n      const type = computed(() => props.type)\n      const sensors = computed(() => store.getters['sensors']) \n      const sensor = computed(() => store.getters['sensor'][type.value])   \n      const setAreaAndScale = (key) => {\n        svg = d3.select(`.Chart-${key}`).append(\"svg\")\n          .attr(\"width\", chartWidth + margin.left + margin.right)\n          .attr(\"height\", chartHeight + margin.top + margin.bottom)\n          .append(\"g\")\n          .attr(\"transform\", `translate(${margin.left},${margin.top})`)\n\n        xScale = d3.scaleTime().range([0, chartWidth])\n        yScale = d3.scaleLinear().range([chartHeight, 0])\n\n        xAxis = d3.axisBottom(xScale).tickFormat(timeFormat)\n        yAxis = d3.axisLeft(yScale)\n\n        area = d3.area()\n          .curve(d3.curveMonotoneX)\n          .x(d => xScale(d.time))\n          .y0(yScale(0))\n          .y1(d => yScale(d[key]))\n\n        line = d3.line().x(d => xScale(d.time)).y(d => yScale(d[key])).curve(d3.curveMonotoneX)\n        tooltip = d3.select(`.tooltip`)\n      }\n\n      const initDraw = (data, key) => {\n        //data는 string형태로 오기 때문에 여기서 new Date 객체로 바꿔주어야 합니다. \n        data.forEach(d => d.time = new Date(d.time)) \n        xScale.domain(d3.extent(data, d => d.time)) \n        const mn = d3.min(data, d => d[key])\n        const mx = d3.max(data, d => d[key])\n        yScale.domain([mn - margin.value, mx + margin.value])\n        svg.append(\"g\")\n          .attr(\"class\", \"x axis\")\n          .attr(\"transform\", `translate(0,${chartHeight})`)\n          .call(xAxis)\n        svg.append(\"g\")\n          .attr(\"class\", \"y axis\")\n          .call(yAxis)\n\n        svg.append(\"path\")\n          .datum(data)\n          .attr(\"fill\", \"steelblue\")\n          .attr(\"d\", area)\n          .attr(\"class\", \"area\")\n\n        //data를 통해 path를 그리는데 3가지 방법이 있다. \n        // svg.append(\"path\").datum(data).attr(\"d\", line)\n        // svg.append(\"path\").data([data]).attr(\"d\", line)   \n        svg.append(\"path\")\n          .attr(\"d\", line(data))\n          .attr(\"class\", \"line\")  \n\n        circle = svg.selectAll(\"dot\")\n          .data(data)\n          .enter().append(\"circle\")\n          .attr(\"r\", 3)\n          .on(\"mouseover\", (event, d) => {\n            console.log(event)\n            console.log(key)\n            tooltip.transition()\n              .duration(200)\n              .style(\"opacity\", 1)\n            const content = `<p>${props.text}</p> <p>[${timeFormat(d.time)}]</p><h2>${d[key]}</h2>`\n\n            tooltip\n              .html(content)\n              .style(\"left\", (event.pageX) - 83 + \"px\")\n              .style(\"top\", (event.pageY) - 130 + \"px\")\n          })\n          .on(\"mouseout\", () => {\n            tooltip.transition()\n              .duration(200)\n              .style(\"opacity\", 0)\n          })\n\n        circle\n          .attr(\"cx\", d => xScale(d.time))\n          .attr(\"cy\", d => yScale(d[key]))\n      }\n      //draw에서는 데이터 처리가 아닌 data를 통해서 차트틀 그리는 것에 대해 집중해야 한다. \n      const draw = (data, key) => {\n        data.forEach(d => d.time = new Date(d.time))\n\n        const mn = d3.min(data, d => d[key])\n        const mx = d3.max(data, d => d[key])\n        xScale.domain(d3.extent(data, d => d.time))\n        yScale.domain([mn - margin.value, mx + margin.value])\n\n        svg.select(\".area\")\n          .transition()\n          .duration(750)\n          .attr(\"d\", area(data))\n\n        svg.select(\".line\")\n          .transition()\n          .duration(750)\n          .attr(\"d\", line(data))\n\n        svg.select(\".x.axis\")\n          .transition()\n          .duration(750)\n          .call(xAxis)\n        svg.select(\".y.axis\")\n          .transition()\n          .duration(750)\n          .call(yAxis)\n\n        circle\n          .data(data)\n          .transition()\n          .duration(750)\n          .attr(\"cx\", d => xScale(d.time))\n          .attr(\"cy\", d => yScale(d[key]))\n      }\n      onMounted(() => {\n        setAreaAndScale(type.value)\n        let flag = false\n        store.subscribe((mutation) => {\n          if (mutation.type === \"CHANGE_SENSOR_CHART\") { \n            if (!flag && sensors.value.length === 10) {\n              initDraw(sensors.value, type.value)\n              flag = true\n            } else if (flag) {\n              draw(sensors.value, type.value)\n            }\n          }\n\n        })\n      })\n      return { \n        sensors,\n        sensor,\n        svg,\n        xScale,\n        yScale,\n        xAxis,\n        yAxis,\n        line,\n        tooltip,\n        circle,  \n      }\n    }\n  }\n</script>\n\n<style>\n   \n</style>"]}]}